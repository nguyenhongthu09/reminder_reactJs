Chỉnh sửa lại:
+gộp 2 form edit và add lại chung với nhau: dùng type để phân biệt nên mở đóng form nào và ngoài ra tạo state: formdata:  để đổ dử liệu khi edit và set rỗng khi mở form add
+ở listnoteHome : tạo state để lưu dữ liệu API của getList và getColor để sau này dùng props  để gọi lại tránh gọi API
+ cap nhat lai input trong edit

+ service nam trong component , chi chua API va update setstate khong duoc goi su kien event
+ doi lai ten cho hop li


+ Edit lai giao dien web
+Các Thuộc tính trong Button

    onClick: Hàm để sử lý khi người dùng nhấp vào nút.​

    lable: Hiển thị văn bản bên trong nút.​

    color: Cài đặt màu nền.​

    disable: Vô hiệu hóa người dùng tương tác với thành phần button.​

    accessibilityLabel: Hiển thị văn bản hỗ trợ người khiếm thị.
    className:Xác định lớp CSS của trường nhập liệu, cho phép bạn tùy chỉnh kiểu dáng bằng CSS.
    type

+Các thuộc tính trong thẻ Input:
    type : xác định loại trường nhập liệu
    value : Xác định giá trị mặc định của trường nhập liệu
    onChange: Xác định hàm xử lý sự kiện khi giá trị của trường nhập liệu thay đổi.
    placeholder: Hiển thị một văn bản gợi ý trong trường nhập liệu, giúp người dùng hiểu rõ hơn về mục đích của trường.
    disabled: Xác định trạng thái vô hiệu hóa của trường nhập liệu
    required: Đánh dấu trường nhập liệu là bắt buộc phải điền.
    className:Xác định lớp CSS của trường nhập liệu, cho phép bạn tùy chỉnh kiểu dáng bằng CSS.

+ Dropdown
        <Dropdown actions={[
    {
        id: 1,
        key: ‘delete’,
        icon: ‘...path’
        onClick: 
    },
    {
        id: 2,
        key: ‘edit’,
        icon: ‘...path’
    },
    {
        id: 3,
        key: ‘move’,
        icon: ‘...path’
    }
]} />
///////////////////////////
class Example extends React.Component {
  constructor() {
    super();
    this.state = {
      value: 0,
    };
  }

  // Function syntax
  handleClickFunction() {
    this.setState((prevState) => ({ value: prevState.value + 1 }));
  }

  // Arrow function syntax
  handleClickArrow = () => {
    // 'this' is bound to the class instance
    this.setState((prevState) => ({ value: prevState.value + 1 }));
  };

  render() {
    return (
      <div>
        <button onClick={this.handleClickFunction.bind(this)}>Click (Function)</button>
        <button onClick={this.handleClickArrow}>Click (Arrow)</button>
      </div>
    );
  }
}
+ Function thông thường: cần sử dụng .bind(this) để đảm bảo rằng this trong hàm handleClickFunction sẽ trỏ đến đúng instance của class Example.
  Nếu không sử dụng bind(this) thì giá trị của this sẽ là undefined khi hàm đó được gọi. 
  Vi hàm thông thường không có ngữ cảnh this được rõ ràng chỉ định, điều này có thể dẫn đến vấn đề khi hàm đó được gọi từ một ngữ cảnh khác nhau.
  Khi bạn đặt một hàm trong một class và gọi nó từ một sự kiện hoặc callback function, giá trị của this trong hàm đó không nhất thiết phải trỏ đến instance của class.
   Điều này có thể gây ra lỗi hoặc không đúng đối với logic mong đợi.
+ Arrow function: không thay đổi giá trị của this. nó sẽ giữ giá trị của this của nó từ ngữ cảnh của hàm bao bọc nó. 
    Do đó, trong trường hợp này, this trong handleClickArrow tự động trỏ đến instance của class Example mà không cần sử dụng .bind(this).
-> Tóm lại, sử dụng .bind(this) với "function syntax" là để đảm bảo rằng this được chính xác trong hàm, trong khi arrow function giữ giá trị this từ ngữ cảnh của nó.


////////////////////////////////////////

+lifecycle: Gồm những phương thức(method) : constructor, render, componentDidMount,componentWillUnmount, componentDidUpdate
    - componentDidMount: được gọi sau khi component đã được render lần đầu tiên và được gắn vào DOM. 
          khởi tạo dữ liệu cho component: gọi API, biến đổi dữ liệu, cập nhật state

    -componentDidUpdate: được gọi sau mỗi lần component được render lại.
    -componentWillUnmount: được gọi trước khi component bị xóa khỏi DOM.
  ---> +Mounting methods: duoc tao ra
          constructor: được gọi đầu tiên khi component được tạo ra.
          static getDerivedStateFromProps: được gọi sau constructor, trước khi component được render lần đầu tiên và sau đó trước mỗi lần cập nhật state hoặc props.
          render: phương thức chính để render ra các element React.
          componentDidMount: được gọi sau khi component đã được render lần đầu tiên và được gắn vào DOM.
       +Updating methods: thay doi
          static getDerivedStateFromProps: được gọi trước mỗi lần cập nhật state hoặc props.
          shouldComponentUpdate: được gọi trước mỗi lần component được render lại để xác định xem component có cần render lại hay không.
          render: phương thức chính để render ra các element React.
          componentDidUpdate: được gọi sau mỗi lần component được render lại.
       +Unmounting methods:  bi huy bo
          componentWillUnmount: được gọi trước khi component bị xóa khỏi DOM.



+ HOOKS 
    - useState : là một hook trong React được sử dụng để khởi tạo và quản lý trạng thái (state) trong Functional Components.
    Khi bạn sử dụng useState thì React sẽ tạo ra một binding dữ liệu một chiều (từ state của component tới UI). 
    Khi state thay đổi React sẽ tự động render lại component để cập nhật giao diện người dùng.

          function ExampleComponent() {
        // Khởi tạo trạng thái với giá trị ban đầu là 0
        const [count, setCount] = useState(0);

        // Hàm tăng giá trị trạng thái
        const incrementCount = () => {
          setCount(count + 1); // Gọi hàm setCount để cập nhật trạng thái
        }

        return (
          <div>
            <p>Count: {count}</p>
            <button onClick={incrementCount}>Increment</button>
          </div>
        );
      }

    -useEffect :  là một trong những hooks quan trọng trong React, được sử dụng để thực hiện các tác vụ phụ (side effects) trong Functional Components. 
    Các tác vụ phụ bao gồm lệnh gọi API, thay đổi trạng thái, đăng ký và hủy đăng ký sự kiện, và các tác vụ không thuộc về việc render giao diện người dùng. 
    useEffect giúp bạn thực hiện các tác vụ này tại các thời điểm cụ thể trong vòng đời của component.
===> // Sử dụng useEffect thay thế cho lifecycle methods. callback se luon duoc goi ngay sau khi component mount. callback se duoc goi khi render
          function ExampleComponent() {
            // Khởi tạo state bằng useState
            const [count, setCount] = useState(0);

            // Sử dụng useEffect thay thế cho lifecycle methods
            useEffect(() => {
              // Thực hiện sau khi component đã được render lần đầu (tương đương với componentDidMount)
              console.log('Component did mount');

              // Cleanup function tương đương với componentWillUnmount
              return () => {
                console.log('Component will unmount');
              };
            }, []); // [] đại diện cho dependencies, rỗng nghĩa là sẽ chỉ thực hiện một lần sau lần render đầu tiên

            // Sử dụng cú pháp arrow function để cập nhật state 
            const incrementCount = () => {
              setCount(count + 1);
            } 

            // Render component
            return (
              <div>
                <p>Count: {count}</p>
                <button onClick={incrementCount}>Increment</button>
              </div>
            );
          }

        + Không cung cấp dependencies: Đóng vai trò như 1 componentDidUpdate và callback sẽ chạy lại mỗi khi component re-render
         nó sẽ chạy sau mỗi lần component được render. Khi bạn nhấn vào nút "Increase Count" để tăng giá trị của count, useEffect sẽ luôn được gọi lại và in ra "useEffect ran." trên console. 
        Điều này có nghĩa rằng nó chạy sau mỗi lần tương tác với component, dù giá trị count có thay đổi hay không.
        Trong nhiều trường hợp, việc không cung cấp dependencies có thể dẫn đến việc gọi useEffect quá nhiều lần và làm cho ứng dụng của bạn hoạt động không hiệu quả.
         Điều này có thể gây ra tải trang chậm hoặc tạo ra các vấn đề hiệu năng khác. (chay vo han)
                function MyComponent() {
          const [count, setCount] = useState(0);

          // useEffect không có dependencies
          useEffect(() => {
            console.log('useEffect ran.');
          });

          return (
            <div>
              <p>Count: {count}</p>
              <button onClick={() => setCount(count + 1)}>Increase Count</button>
            </div>
          );
        }
        +Dependencies là mảng rỗng: đóng vai trò như 1 componentDidMount. callback chạy duy nhất 1 lần sau khi component render lần đầu 
        Điều này đồng nghĩa với việc nó chỉ chạy một lần sau khi component được render lần đầu tiên. 
        Khi bạn nhấn vào nút "Increase Count" để tăng giá trị của count, useEffect sẽ không bao giờ được gọi lại. 
        Điều này thích hợp cho các tác vụ mà bạn chỉ muốn thực hiện một lần và không muốn chúng phụ thuộc vào bất kỳ giá trị nào. 
        Cách hoạt động tương tự như componentDidMount của Class Component.
        function MyComponent() {
        const [count, setCount] = useState(0);

        // useEffect với mảng dependencies rỗng
        useEffect(() => {
          console.log('useEffect ran.');
        }, []);

        return (
          <div>
            <p>Count: {count}</p>
            <button onClick={() => setCount(count + 1)}>Increase Count</button>
          </div>
        );
      }

      + Dependencies là props hoặc state:đóng vai trò như 1 componentDidMount, nhưng khi giá trị của dependencies bị thay đổi thì callback sẽ được chạy lại.
      Khi bạn truyền dependencies là props hoặc state, useEffect sẽ được gọi lại mỗi khi giá trị của dependencies thay đổi.
       Điều này thường được sử dụng để thực hiện các tác vụ phụ thuộc vào sự thay đổi của props hoặc state. 
      Cơ chế này tương tự như bạn sử dụng Life Cycle componentDidUpdate và shouldComponentUpdate của Class Component.
        function ExampleComponent() {
          const [count, setCount] = useState(0);

          // thay đổi giá trị của count
          const incrementCount = () => {
            setCount(count + 1);
          }
          
          // không thay đổi giá trị của count
          const doNothing = () => {
            setCount(count);
          }

          // useEffect callback được gọi khi state thay đổi so với giá trị trước đó
          useEffect(() => {
            console.log("useEffect ran.");
          }, [count])
        
          return (
            <section>
              <h1>{count}</h1>

              <button onClick={incrementCount}>Tăng thêm</button>
              <button onClick={doNothing}>Không có gì xảy ra</button>
            </section>
          ); 
        }

        +Clear up function dùng để chạy trước khi callback chạy lại lần tiếp theo.
         Có thể áp dụng để hủy đăng kí hoặc hủy gọi API trước khi component của chúng ta bị destroy. 
        Tương tự componentWillUnMount bên class.


    +UseRef:  Lưu các giá trị cua tham chieu va trich xuat den cac thanh phan dom 1 cach cu the.
    là một hook trong React được sử dụng để tạo một tham chiếu (reference)
     đến một phần tử DOM hoặc để lưu trữ các giá trị mà bạn muốn duy trì giữa các chu kỳ render của component
      mà không gây ra việc render lại khi giá trị thay đổi.
      function ExampleComponent() {
          const countRef = useRef(0);
          const [count, setCount] = useState(0);

          const incrementCount = () => {
            // Sử dụng `countRef` để lưu trữ giá trị không gây ra việc render lại
            countRef.current = countRef.current + 1;

            // Sử dụng `setCount` để cập nhật giá trị trong state và gây ra việc render lại
            setCount(count + 1);
          };

          return (
            <div>
              <p>Count (state): {count}</p>
              <p>Count (ref): {countRef.current}</p>
              <button onClick={incrementCount}>Increment Count</button>
            </div>
          );
        }

      - Truy cập và thao tác với phần tử DOM:thiết lập trạng thái focus, thay đổi kích thước hoặc vị trí của phần tử, thì useRef là sự lựa chọn phù hợp
          componentDidMount() {
              this.myInput.focus();
            }
    +UseCallBack :và nó trả về là 1 callback
     là một hook trong React được sử dụng để tối ưu hóa hiệu suất của ứng dụng bằng cách lưu giữ một hàm callback và chỉ tính toán lại nó khi các dependencies của nó thay đổi.
     tránh tạo ra những hàm mới không cần thiết trong func component.
    hoặc khi không muốn func được khởi tạo lại mỗi lần component re-render.
          const memoizedCallback = useCallback((type) => {
        // Hàm callback của bạn ở đây
      }, [dependencies]);
no se tra ve ham :(type) => {
        // Hàm callback của bạn ở đây
      }

          -Trong đó:
            Hàm callback của bạn nằm trong hàm useCallback.
            [dependencies] là mảng dependencies. Hàm callback sẽ chỉ được tính toán lại khi các giá trị trong mảng này thay đổi.
                constructor(props) {
                super(props);
                this.state = {
                  count: 0,
                };

                // Sử dụng useCallback để memoize hàm handleButtonClick
                this.handleButtonClick = useCallback(this.handleButtonClick.bind(this), []);
              }

              handleButtonClick() {
                this.setState((prevState) => ({
                  count: prevState.count + 1,
                }));
              }
    +UseMemo : trả về giá trị value
    lưu giữ kết quả của một hàm tính toán và trả về giá trị đó khi các dependencies của nó không thay đổi
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
tra ve gia tri : computeExpensiveValue(a, b)
      dung tuong tu : shouldComponentUpdate
--> nen dung callback va memo : do thi, bieu do, animations, nhung component nang ve render